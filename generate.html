<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <style>

      /*
        CHANGE THIS to give your minimaps a background color behind the map
      */
      body {
        background-color: transparent;
        background-color: #ccc;
      }

      svg {
        border: 1px solid green;
      }

      /* 
        Style for background layer
        CHANGE THIS to make it something other than white
      */
      g.background path {
        stroke: none;
        fill: #fff;
      }

      /* 
        Style for the highlighted district
        CHANGE THIS to make it something other than black
      */
      g.foreground path {
        fill: #000;
        stroke: none;
      }

      /* 
        Style for the rectangle around the highlighted district
        CHANGE THIS to make it something other than a sharp 1px red rectangle
      */
      rect {
        stroke-width: 1px;
        stroke: #e51133;
        fill: none;
        shape-rendering: crispEdges;
      }

      * {
        margin: 0;
        padding: 0;
        outline: 0;
      }

      g.foreground {
        display: none;
      }

      g.foreground.show {
        display: block;
      }

    </style>
  </head>
  <body>
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <script src="http://d3js.org/queue.v1.min.js"></script>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
    <script src="http://project.wnyc.org/assets/js/jquery.url.min.js"></script>
    <script>

      //Initialize stuff
      var projection,
          path,
          background,
          foreground,
          config,
          q = queue();

      d3.json("config.json",function(err,c){
        if (err) {
          return console.log(err);
        }

        config = c;

        //Map projection, auto fit based on width, height, and the background or foreground layer
        projection = d3.geo.mercator()
          .scale(2000) //NJ statewide scale (CHANGE THIS)
          .center([-74.7312335,40.15382869170064]) //projection center (CHANGE THIS)
          .translate([config.width/2,config.height/2]);

        if (config.backgroundFile) {
          q.defer(d3.json,config.backgroundFile);
        } else {
          q.defer(empty);
        }

        if (config.foregroundFile) {
          q.defer(d3.json,config.foregroundFile);
        }

        q.await(initialize);

      })

      function initialize(err,bg,fg){

        if (err) {
          return console.log(err);
        }

        //Generate paths based on projection
        path = d3.geo.path()
            .projection(projection);

        var svg = d3.select("body").append("svg")
                      .attr("width",config.width)
                      .attr("height",config.height);

        background = svg.append("g").attr("class","background");

        background.selectAll("path")
          .data(bg.features)
          .enter()
            .append("path")
            .attr("d",path);


        if (config.useBoxes) {
          fg.features = fg.features.map(withBox);
        }

        //Append individual districts
        foreground = svg.selectAll("g.foreground")
           .data(fg.features)
           .enter()
           .append("g")
            .attr("class","foreground");

        //Black paths for districts
        foreground.append("path")
           .attr("d",path);

        //Add red rectangles around districts
        //You could make these circles instead, or something else crazy
        if (config.useBoxes) {
          foreground.append("rect")
            .attr("x",function(d){
              return d.minimapBox.x;
            })
            .attr("y",function(d){
              return d.minimapBox.y;
            })
            .attr("width",function(d){
              return d.minimapBox.width;
            })
            .attr("height",function(d){
              return d.minimapBox.height;
            });
        }

        //If they're loading a specific district, show that
        if ($.url.param("highlight")) {
          highlight($.url.param("highlight"));
        }

        highlight(2);

      }

      //Highlight a specific district number
      function highlight(name) {

        //Show the feature
        foreground.classed("show",function(d){
          return d.properties[config.propName] && d.properties[config.propName]+"" == name+"";
        });

      }

      //For a dummy response to queue
      function empty(cb) {
        cb(null,null);
      }

      //Calculates an x/y and width/height for a bounding rectangle around a feature
      function withBox(d) {

        //Get the X/Y bounds of this district
        var b = path.bounds(d);

        //MAAAAAATH
        //Calculate the dimensions of the red rectangle
        //Adjust it if it would bleed out of the map
        //Change this if you want them sized differently
        //If you want circles instead, figure out how to calculate the radius instead

        //Initial width/height
        var w = b[1][0]-b[0][0],
            h = b[1][1]-b[0][1];

        //Expanded to be double the actual bounds, minimum 15px x 15px
        var minimapBox = {
          "width": Math.max(15,w*2),
          "height": Math.max(15,h*2)
        };

        minimapBox.x = b[0][0]-((minimapBox.width-w)/2);
        minimapBox.y = b[0][1]-((minimapBox.height-h)/2);

        //If the rectangle is past left edge, shrink the width
        if (minimapBox.x < 1) {

          minimapBox.x = 1;

          minimapBox.width = (2*(b[0][0]-minimapBox.x))+(b[1][0]-b[0][0]);

        }

        //If the rectangle is past the right edge, shrink the width
        if (minimapBox.x+minimapBox.width > config.width - 1) {

          var xDiff = minimapBox.x+minimapBox.width - (config.width - 1);

          minimapBox.x += xDiff;
          minimapBox.width -= xDiff*2;

        }

        //If the rectangle is above the top edge, shrink the height
        if (minimapBox.y < 1) {

          minimapBox.y = 1;

          minimapBox.height = (2*(b[0][1]-minimapBox.y))+(b[1][1]-b[0][1]);

        }

        //If the rectangle is below the bottom edge, shrink the height
        if (minimapBox.y+minimapBox.height > config.height - 1) {

          var yDiff = minimapBox.y+minimapBox.height - (config.height - 1);

          minimapBox.y += yDiff;
          minimapBox.height -= yDiff*2;

        }

        d.minimapBox = minimapBox;

        return d;

      }

    </script>
  </body>
</html>